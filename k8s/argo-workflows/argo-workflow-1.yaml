---
# Source: argo-workflows/templates/argo-serviceaccounts.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: argo
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
---
# Source: argo-workflows/templates/argo-serviceaccounts.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: argo-server
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
---
# Source: argo-workflows/templates/argo-pg-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: argo-pg-secret
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
type: Opaque
stringData:
  username: "argo"
  password: "dbpass1234"
---
# Source: argo-workflows/templates/postgresql-secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: argo-workflow-1-postgresql-secret
  labels:
    app.kubernetes.io/name: argo-workflow-1
    app.kubernetes.io/component: postgresql-server
type: Opaque
data:
  db-user: "YXJnbw=="
  db-password: "ZGJwYXNzMTIzNA=="
---
# Source: argo-workflows/templates/argo-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  namespace: "default"
  name: workflow-controller-configmap
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
data:
  executor: |
    resources:
      requests:
        cpu: 10m
        memory: 64Mi
  images: |
    docker/whalesay:latest:
       cmd: [cowsay]
  links: |
    - name: Workflow Link
      scope: workflow
      url: http://logging-facility?namespace=${metadata.namespace}&workflowName=${metadata.name}&startedAt=${status.startedAt}&finishedAt=${status.finishedAt}
    - name: Pod Link
      scope: pod
      url: http://logging-facility?namespace=${metadata.namespace}&podName=${metadata.name}&startedAt=${status.startedAt}&finishedAt=${status.finishedAt}
    - name: Pod Logs Link
      scope: pod-logs
      url: http://logging-facility?namespace=${metadata.namespace}&podName=${metadata.name}&startedAt=${status.startedAt}&finishedAt=${status.finishedAt}
    - name: Event Source Logs Link
      scope: event-source-logs
      url: http://logging-facility?namespace=${metadata.namespace}&podName=${metadata.name}&startedAt=${status.startedAt}&finishedAt=${status.finishedAt}
    - name: Sensor Logs Link
      scope: sensor-logs
      url: http://logging-facility?namespace=${metadata.namespace}&podName=${metadata.name}&startedAt=${status.startedAt}&finishedAt=${status.finishedAt}
  metricsConfig: |
    enabled: true
    path: /metrics
    port: 9090
  namespaceParallelism: "10"
  persistence: |
    connectionPool:
      maxIdleConns: 100
      maxOpenConns: 0
      connMaxLifetime: 0s
    nodeStatusOffLoad: true
    archive: true
    archiveTTL: 7d
    postgresql:
      host: "argo-workflow-1-postgresql-svc"
      port: 5432
      database: "argo_workflows"
      tableName: "argo_workflows"
      userNameSecret:
        name: argo-pg-secret
        key: username
      passwordSecret:
        name: argo-pg-secret
        key: password
  retentionPolicy: |
    completed: 10
    failed: 3
    errored: 3
---
# Source: argo-workflows/templates/argo-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: argo-clusterworkflowtemplate-role
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
rules:
- apiGroups:
  - argoproj.io
  resources:
  - clusterworkflowtemplates
  - clusterworkflowtemplates/finalizers
  verbs:
  - get
  - list
  - watch
---
# Source: argo-workflows/templates/argo-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: argo-server-clusterworkflowtemplate-role
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
rules:
- apiGroups:
  - argoproj.io
  resources:
  - clusterworkflowtemplates
  - clusterworkflowtemplates/finalizers
  verbs:
  - create
  - delete
  - watch
  - get
  - list
  - watch
---
# Source: argo-workflows/templates/argo-rolebindings.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: argo-clusterworkflowtemplate-role-binding
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: argo-clusterworkflowtemplate-role
subjects:
- kind: ServiceAccount
  name: argo
  namespace: "default"
---
# Source: argo-workflows/templates/argo-rolebindings.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: argo-server-clusterworkflowtemplate-role-binding
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: argo-server-clusterworkflowtemplate-role
subjects:
- kind: ServiceAccount
  name: argo-server
  namespace: "default"
---
# Source: argo-workflows/templates/argo-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  annotations:
    workflows.argoproj.io/description: |
      This is the minimum recommended permissions needed if you want to use the agent, e.g. for HTTP or plugin templates.
      If <= v3.2 you must replace `workflowtasksets/status` with `patch workflowtasksets`.
  name: agent
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
rules:
- apiGroups:
  - argoproj.io
  resources:
  - workflowtasksets
  verbs:
  - list
  - watch
- apiGroups:
  - argoproj.io
  resources:
  - workflowtasksets/status
  verbs:
  - patch
---
# Source: argo-workflows/templates/argo-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: argo-role
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
rules:
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  verbs:
  - create
  - get
  - update
- apiGroups:
  - ""
  resources:
  - pods
  - pods/exec
  verbs:
  - create
  - get
  - list
  - watch
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - watch
  - list
- apiGroups:
  - ""
  resources:
  - persistentvolumeclaims
  - persistentvolumeclaims/finalizers
  verbs:
  - create
  - update
  - delete
  - get
- apiGroups:
  - argoproj.io
  resources:
  - workflows
  - workflows/finalizers
  - workflowtasksets
  - workflowtasksets/finalizers
  - workflowartifactgctasks
  verbs:
  - get
  - list
  - watch
  - update
  - patch
  - delete
  - create
- apiGroups:
  - argoproj.io
  resources:
  - workflowtemplates
  - workflowtemplates/finalizers
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - argoproj.io
  resources:
  - workflowtaskresults
  verbs:
  - list
  - watch
  - deletecollection
- apiGroups:
  - ""
  resources:
  - serviceaccounts
  verbs:
  - get
  - list
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
- apiGroups:
  - argoproj.io
  resources:
  - cronworkflows
  - cronworkflows/finalizers
  verbs:
  - get
  - list
  - watch
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
- apiGroups:
  - policy
  resources:
  - poddisruptionbudgets
  verbs:
  - create
  - get
  - delete
---
# Source: argo-workflows/templates/argo-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: argo-server-role
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
rules:
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - watch
  - list
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - create
- apiGroups:
  - ""
  resources:
  - pods
  - pods/exec
  - pods/log
  verbs:
  - get
  - list
  - watch
  - delete
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - watch
  - create
  - patch
- apiGroups:
  - ""
  resources:
  - serviceaccounts
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - argoproj.io
  resources:
  - eventsources
  - sensors
  - workflows
  - workfloweventbindings
  - workflowtemplates
  - cronworkflows
  - cronworkflows/finalizers
  verbs:
  - create
  - get
  - list
  - watch
  - update
  - patch
  - delete
---
# Source: argo-workflows/templates/argo-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  annotations:
    workflows.argoproj.io/description: |
      This is the minimum recommended permissions needed if you want to use artifact GC.
  name: artifactgc
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
rules:
- apiGroups:
  - argoproj.io
  resources:
  - workflowartifactgctasks
  verbs:
  - list
  - watch
- apiGroups:
  - argoproj.io
  resources:
  - workflowartifactgctasks/status
  verbs:
  - patch
---
# Source: argo-workflows/templates/argo-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  annotations:
    workflows.argoproj.io/description: |
      Recomended minimum permissions for the `emissary` executor.
  name: executor
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
rules:
- apiGroups:
  - argoproj.io
  resources:
  - workflowtaskresults
  verbs:
  - create
  - patch
---
# Source: argo-workflows/templates/argo-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  annotations:
    workflows.argoproj.io/description: |
      This is an example of the permissions you would need if you wanted to use a resource template to create and manage
      other pods. The same pattern would be suitable for other resurces, e.g. a service
  name: pod-manager
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - create
  - get
  - patch
---
# Source: argo-workflows/templates/argo-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: submit-workflow-template
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
rules:
- apiGroups:
  - argoproj.io
  resources:
  - workfloweventbindings
  verbs:
  - list
- apiGroups:
  - argoproj.io
  resources:
  - workflowtemplates
  verbs:
  - get
- apiGroups:
  - argoproj.io
  resources:
  - workflows
  verbs:
  - create
---
# Source: argo-workflows/templates/argo-roles.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  annotations:
    workflows.argoproj.io/description: |
      This is an example of the permissions you would need if you wanted to use a resource template to create and manage
      other workflows. The same pattern would be suitable for other resurces, e.g. a service
  name: workflow-manager
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
rules:
- apiGroups:
  - argoproj.io
  resources:
  - workflows
  verbs:
  - create
  - get
---
# Source: argo-workflows/templates/argo-rolebindings.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: agent-default
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: agent
subjects:
- kind: ServiceAccount
  name: default
---
# Source: argo-workflows/templates/argo-rolebindings.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: argo-binding
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: argo-role
subjects:
- kind: ServiceAccount
  name: argo
---
# Source: argo-workflows/templates/argo-rolebindings.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: argo-server-binding
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: argo-server-role
subjects:
- kind: ServiceAccount
  name: argo-server
---
# Source: argo-workflows/templates/argo-rolebindings.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: artifactgc-default
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: artifactgc
subjects:
- kind: ServiceAccount
  name: default
---
# Source: argo-workflows/templates/argo-rolebindings.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: executor-default
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: executor
subjects:
- kind: ServiceAccount
  name: default
---
# Source: argo-workflows/templates/argo-rolebindings.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: pod-manager-default
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: pod-manager
subjects:
- kind: ServiceAccount
  name: default
---
# Source: argo-workflows/templates/argo-rolebindings.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: workflow-manager-default
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: workflow-manager
subjects:
- kind: ServiceAccount
  name: default
---
# Source: argo-workflows/templates/argo-services.yaml
apiVersion: v1
kind: Service
metadata:
  name: argo-server
  namespace: "default"
spec:
  type: NodePort
  ports:
  - name: web
    port: 2746
    targetPort: 2746
  selector:
    app: "argo-workflow-1-server"
---
# Source: argo-workflows/templates/argo-services.yaml
apiVersion: v1
kind: Service
metadata:
  name: argo-controller
spec:
  ports:
  - name: metrics
    port: 9090
    targetPort: 9090
  selector:
    app: "argo-workflow-1-controller"
---
# Source: argo-workflows/templates/postgresql-services.yaml
apiVersion: v1
kind: Service
metadata:
  name: argo-workflow-1-postgresql-svc
  labels: &PostgreSQLLabels
    app.kubernetes.io/name: argo-workflow-1
    app.kubernetes.io/component: postgresql-server
spec:
  ports:
  - name: postgres
    port: 5432
    targetPort: 5432
  selector: *PostgreSQLLabels
  type: ClusterIP
---
# Source: argo-workflows/templates/postgresql-services.yaml
kind: Service
apiVersion: v1
metadata:
  name: argo-workflow-1-postgresql-exporter-svc
  labels: &PostgreSQLLabels
    app.kubernetes.io/name: argo-workflow-1
    app.kubernetes.io/component: postgresql-server
spec:
  ports:
  - name: prometheus-exporter
    port: 9187
  selector: *PostgreSQLLabels
  type: ClusterIP
---
# Source: argo-workflows/templates/argocontroller-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: "argo-workflow-1-controller"
  namespace: "default"
spec:
  selector:
    matchLabels:
      app: "argo-workflow-1-controller"
      app.kubernetes.io/name: "argo-workflow-1-controller"
  template:
    metadata:
      labels:
        app: "argo-workflow-1-controller"
        app.kubernetes.io/name: "argo-workflow-1-controller"
    spec:
      initContainers:        
        - name: check-db
          image: marketplace.gcr.io/google/debian11
          imagePullPolicy: IfNotPresent
          command:
            - sh
            - -c
            - |
              apt update && apt -y install netcat
              echo 'Waiting for PostgreSQL to become ready...'
              until printf "." && nc -z -w 2 "argo-workflow-1-postgresql-svc" 5432; do
                sleep 2;
              done;
              echo 'PostgreSQL is ready'
      containers:
      - name: workflow-controller
        image: "gcr.io/ccm-ops-test-adhoc/argo-workflow3:3.4"
        args:
        - --namespaced
        env:
        - name: MODE
          value: controller
        - name: LEADER_ELECTION_IDENTITY
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.name
        livenessProbe:
          failureThreshold: 3
          httpGet:
            path: /healthz
            port: 6060
          initialDelaySeconds: 90
          periodSeconds: 60
          timeoutSeconds: 30
        ports:
        - containerPort: 9090
          name: metrics
        - containerPort: 6060
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
      nodeSelector:
        kubernetes.io/os: linux
      serviceAccountName: argo
---
# Source: argo-workflows/templates/argoserver-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: "argo-workflow-1-server"
  namespace: "default"
  labels:
    app.kubernetes.io/name: "argo-workflow-1-server"
spec:
  selector:
    matchLabels:
      app: "argo-workflow-1-server"
  template:
    metadata:
      labels:
        app: "argo-workflow-1-server"
    spec:
      initContainers:        
        - name: check-db
          image: marketplace.gcr.io/google/debian11
          imagePullPolicy: IfNotPresent
          command:
            - sh
            - -c
            - |
              apt update && apt -y install netcat
              echo 'Waiting for PostgreSQL to become ready...'
              until printf "." && nc -z -w 2 "argo-workflow-1-postgresql-svc" 5432; do
                sleep 2;
              done;
              echo 'PostgreSQL is ready'
      containers:
      - name: argo-server
        image: "gcr.io/ccm-ops-test-adhoc/argo-workflow3:3.4"
        args:
        - server
        - --namespaced
        - --auth-mode
        - server
        - --auth-mode
        - client
        env:
        - name: MODE
          value: "cli"
        ports:
        - containerPort: 2746
          name: web
        readinessProbe:
          httpGet:
            path: /
            port: 2746
            scheme: HTTPS
          initialDelaySeconds: 10
          periodSeconds: 20
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
          runAsNonRoot: true
        volumeMounts:
        - mountPath: /tmp
          name: tmp
      nodeSelector:
        kubernetes.io/os: linux
      serviceAccountName: argo-server
      volumes:
      - emptyDir: {}
        name: tmp
---
# Source: argo-workflows/templates/postgresql-statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: argo-workflow-1-postgresql
  labels: &PostgreSQLLabels
    app.kubernetes.io/name: argo-workflow-1
    app.kubernetes.io/component: postgresql-server
spec:
  replicas: 1
  selector:
    matchLabels: *PostgreSQLLabels
  serviceName: argo-workflow-1-postgresql-svc
  template:
    metadata:
      labels: *PostgreSQLLabels
    spec:
      containers:
      - name: postgresql
        image: marketplace.gcr.io/google/postgresql14
        imagePullPolicy: IfNotPresent
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        ports:
        - containerPort: 5432
          name: postgres
        volumeMounts:
        - name: argo-workflow-1-postgresql-pvc
          mountPath: /var/lib/postgresql/data
        env:
        - name: PGDATA
          value: "/var/lib/postgresql/data/pgdata"
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: argo-workflow-1-postgresql-secret
              key: db-user
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: argo-workflow-1-postgresql-secret
              key: db-password
        - name: POSTGRES_DB
          value: "argo_workflows"
      - name: prometheus-exporter
        image: marketplace.gcr.io/google/postgresql-exporter0
        imagePullPolicy: Always
        ports:
        - containerPort: 9187
          name: exporter
        env:
        - name: "DATA_SOURCE_URI"
          value: "localhost:5432/postgres?sslmode=disable"
        - name: "DATA_SOURCE_USER"
          valueFrom:
            secretKeyRef:
              name: argo-workflow-1-postgresql-secret
              key: db-user
        - name: "DATA_SOURCE_PASS"
          valueFrom:
            secretKeyRef:
              name: argo-workflow-1-postgresql-secret
              key: db-password
  volumeClaimTemplates:
  - metadata:
      name: argo-workflow-1-postgresql-pvc
      labels: *PostgreSQLLabels
    spec:
      accessModes:
      - ReadWriteOnce
      storageClassName: standard
      resources:
        requests:
          storage: 8Gi
